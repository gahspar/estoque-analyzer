import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
from estoque_analyzer import EstoqueAnalyzer
from analise_avancada import AnaliseAvancada

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="An√°lise de Estoque Avan√ßada",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# T√≠tulo e descri√ß√£o
st.title("üìä An√°lise de Estoque Avan√ßada")
st.markdown("""
Sistema inteligente para an√°lise de estoque com previs√£o de demanda baseada em m√©dia de pacientes.
Especialmente otimizado para **medicamentos em unidades de sa√∫de**.
""")

# Sidebar com configura√ß√µes
with st.sidebar:
    st.header("‚öôÔ∏è Configura√ß√µes")
    
    # Sele√ß√£o de tipo de produto
    tipo_produto = st.selectbox(
        "Tipo de Produto",
        ["medicamentos", "insumos", "equipamentos"],
        help="Selecione o tipo de produto para aplicar fatores de corre√ß√£o espec√≠ficos"
    )
    
    # M√©dia de pacientes (obrigat√≥rio para c√°lculo)
    media_pacientes = st.number_input(
        "M√©dia Mensal de Pacientes",
        min_value=1,
        value=1000,
        help="M√©dia mensal de pacientes para c√°lculo de demanda esperada e previs√£o de estoque"
    )
    
    # Per√≠odo de previs√£o
    periodo_previsao = st.selectbox(
        "Per√≠odo de Previs√£o",
        [30, 60, 90, 180, 365],
        format_func=lambda x: f"{x} dias",
        help="Per√≠odo para calcular o estoque ideal futuro"
    )
    
    st.divider()
    
    st.header("üìã Instru√ß√µes")
    st.markdown("""
    1. **Planilha de Estoque Atual**: Deve conter as colunas:
       - C√≥digo do produto
       - Descri√ß√£o
       - Unidade de medida
       - Quantidade em estoque
    
    2. **Planilha de Sa√≠das Mensais**: Deve conter as colunas:
       - C√≥digo do produto
       - Descri√ß√£o
       - Unidade de medida
       - Quantidade de sa√≠das
    """)
    
    st.header("‚ÑπÔ∏è Sobre")
    st.markdown("""
    **Funcionalidades:**
    - üéØ Previs√£o de demanda baseada em pacientes
    - üìà C√°lculo de estoque ideal futuro
    - üí° Sugest√µes inteligentes de compra
    - üîî Alertas e recomenda√ß√µes
    
    **Status:**
    - üü¢ OK: Estoque suficiente
    - üî¥ Comprar: Necessita reposi√ß√£o
    """)

def criar_metricas_principais(resultado):
    """Cria m√©tricas principais do dashboard"""
    if resultado is None or len(resultado) == 0:
        return
    
    # Calcular m√©tricas
    total_produtos = len(resultado)
    produtos_ok = len(resultado[resultado['Situa√ß√£o'] == 'OK'])
    produtos_comprar = len(resultado[resultado['Situa√ß√£o'] == 'Comprar'])
    valor_total_estoque = resultado['Quantidade em estoque'].sum()
    
    # M√©tricas em colunas
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Total de Produtos", 
            total_produtos,
            help="N√∫mero total de produtos analisados"
        )
    
    with col2:
        st.metric(
            "Status OK", 
            produtos_ok, 
            delta=f"{produtos_ok/total_produtos*100:.1f}%",
            delta_color="normal",
            help="Produtos com estoque suficiente"
        )
    
    with col3:
        st.metric(
            "Precisa Comprar", 
            produtos_comprar, 
            delta=f"{produtos_comprar/total_produtos*100:.1f}%",
            delta_color="inverse",
            help="Produtos que precisam de reposi√ß√£o"
        )
    
    with col4:
        st.metric(
            "Valor Total Estoque", 
            f"{valor_total_estoque:,.0f}",
            help="Soma total de todas as quantidades em estoque"
        )

def exibir_recomendacoes(resultado):
    """Exibe recomenda√ß√µes baseadas na an√°lise"""
    if resultado is None or len(resultado) == 0:
        return
    
    analise = AnaliseAvancada()
    recomendacoes = analise.gerar_recomendacoes(resultado)
    
    st.subheader("üí° Recomenda√ß√µes Inteligentes")
    
    for rec in recomendacoes:
        with st.expander(f"üîî {rec['titulo']}"):
            st.write(rec['descricao'])
            
            if rec['produtos']:
                df_rec = pd.DataFrame(rec['produtos'])
                st.dataframe(df_rec, use_container_width=True, hide_index=True)

def exibir_tabela_resultados(resultado):
    """Exibe tabela de resultados com formata√ß√£o"""
    if resultado is None or len(resultado) == 0:
        return
    
    st.subheader("üìã Resultado da An√°lise")
    
    # Aplicar formata√ß√£o condicional
    def color_situacao(val):
        if val == 'Comprar':
            return 'background-color: #ffcccc; color: #cc0000; font-weight: bold'
        return 'background-color: #ccffcc; color: #006600; font-weight: bold'
    
    # Formatar n√∫meros
    resultado_formatado = resultado.copy()
    resultado_formatado['Quantidade em estoque'] = resultado_formatado['Quantidade em estoque'].apply(lambda x: f"{x:,.0f}")
    resultado_formatado['M√©dia de Sa√≠da Mensal'] = resultado_formatado['M√©dia de Sa√≠da Mensal'].apply(lambda x: f"{x:,.2f}")
    resultado_formatado['Demanda Esperada'] = resultado_formatado['Demanda Esperada'].apply(lambda x: f"{x:,.2f}")
    resultado_formatado['Estoque Restante Estimado'] = resultado_formatado['Estoque Restante Estimado'].apply(lambda x: f"{x:,.2f}")
    resultado_formatado['Prazo Estoque (dias)'] = resultado_formatado['Prazo Estoque (dias)'].apply(lambda x: f"{x:,.1f}")
    resultado_formatado['Quantidade Sugerida Compra'] = resultado_formatado['Quantidade Sugerida Compra'].apply(lambda x: f"{x:,.2f}")
    resultado_formatado['Estoque Ideal Futuro'] = resultado_formatado['Estoque Ideal Futuro'].apply(lambda x: f"{x:,.2f}")
    
    # Exibir tabela com formata√ß√£o
    st.dataframe(
        resultado_formatado.style.map(color_situacao, subset=['Situa√ß√£o']),
        use_container_width=True,
        hide_index=True
    )

def exportar_excel(resultado):
    """Exporta os resultados para um arquivo Excel"""
    try:
        with st.spinner("Gerando arquivo Excel..."):
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"analise_estoque_avancada_{timestamp}.xlsx"
            
            # Salvar arquivo tempor√°rio
            resultado.to_excel(filename, sheet_name='An√°lise Avan√ßada', index=False, engine='openpyxl')
            
            # Ler o arquivo e preparar para download
            with open(filename, 'rb') as f:
                file_content = f.read()
            
            # Limpar arquivo tempor√°rio
            import os
            if os.path.exists(filename):
                os.remove(filename)
            
            # Download
            st.download_button(
                label="üíæ Baixar arquivo Excel",
                data=file_content,
                file_name=filename,
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key=f"download_{timestamp}"
            )
            
            st.success(f"‚úÖ Arquivo '{filename}' gerado com sucesso!")
        
    except Exception as e:
        st.error(f"‚ùå Erro ao exportar arquivo: {str(e)}")

def main():
    # Upload das planilhas
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìÅ Upload - Estoque Atual")
        estoque_file = st.file_uploader(
            "Selecione a planilha de estoque atual",
            type=['xlsx', 'xls'],
            key="estoque"
        )
    
    with col2:
        st.subheader("üìÅ Upload - Sa√≠das Mensais")
        saidas_file = st.file_uploader(
            "Selecione a planilha de sa√≠das mensais",
            type=['xlsx', 'xls'],
            key="saidas"
        )
    
    # Configura√ß√£o manual (opcional)
    st.markdown("---")
    st.subheader("‚öôÔ∏è Configura√ß√£o Manual (opcional)")
    config_manual = {}
    with st.expander("Ajustar leitura manualmente se necess√°rio"):
        st.write("Se a detec√ß√£o autom√°tica n√£o funcionar, ajuste aqui:")
        col3, col4 = st.columns(2)
        with col3:
            linha_inicio_estoque = st.number_input("Linha de in√≠cio dos dados de estoque (0 = auto)", min_value=0, value=0)
            mapeamento_estoque = st.text_input("Mapeamento colunas estoque (ex: 0,codigo;1,descricao;2,unidade;14,estoque)", value="")
        with col4:
            linha_inicio_saidas = st.number_input("Linha de in√≠cio dos dados de sa√≠das (0 = auto)", min_value=0, value=0)
            mapeamento_saidas = st.text_input("Mapeamento colunas sa√≠das (ex: 0,codigo;1,descricao;2,unidade;14,saida)", value="")
        if linha_inicio_estoque > 0:
            config_manual['linha_inicio_estoque'] = linha_inicio_estoque
        if linha_inicio_saidas > 0:
            config_manual['linha_inicio_saidas'] = linha_inicio_saidas
        if mapeamento_estoque:
            config_manual['mapeamento_estoque'] = parse_mapeamento(mapeamento_estoque)
        if mapeamento_saidas:
            config_manual['mapeamento_saidas'] = parse_mapeamento(mapeamento_saidas)
    
    # Bot√£o de an√°lise
    if st.button("üîç Analisar Estoque", type="primary", use_container_width=True):
        if estoque_file is None or saidas_file is None:
            st.error("‚ùå Por favor, fa√ßa upload de ambas as planilhas para continuar.")
            return
        
        try:
            with st.spinner("Analisando dados com an√°lise avan√ßada..."):
                analyzer = EstoqueAnalyzer()
                resultado = analyzer.analisar_estoque(
                    estoque_file, 
                    saidas_file, 
                    config_manual if config_manual else None,
                    tipo_produto,
                    media_pacientes,
                    periodo_previsao
                )
                
                if resultado is None:
                    st.error("‚ùå Erro ao processar os arquivos. Verifique se as colunas est√£o corretas ou ajuste manualmente.")
                    return
                
                # Salvar resultado na sess√£o
                st.session_state['resultado'] = resultado
                st.session_state['analise_feita'] = True
                st.session_state['tipo_produto'] = tipo_produto
                st.session_state['media_pacientes'] = media_pacientes
                st.session_state['periodo_previsao'] = periodo_previsao
                
        except Exception as e:
            st.error(f"‚ùå Erro durante a an√°lise: {str(e)}")
            st.exception(e)
    
    # Mostrar resultados se j√° foram calculados
    if 'analise_feita' in st.session_state and st.session_state['analise_feita']:
        resultado = st.session_state['resultado']
        
        # Informa√ß√µes da an√°lise
        st.markdown("---")
        st.subheader("üìä Resultados da An√°lise")
        
        # Informa√ß√µes do tipo de produto e configura√ß√µes
        col_info1, col_info2, col_info3 = st.columns(3)
        with col_info1:
            st.info(f"üéØ **Tipo de Produto:** {st.session_state['tipo_produto'].title()}")
        with col_info2:
            st.info(f"üë• **M√©dia de Pacientes:** {st.session_state['media_pacientes']:,} pacientes/m√™s")
        with col_info3:
            st.info(f"üìÖ **Per√≠odo de Previs√£o:** {st.session_state['periodo_previsao']} dias")
        
        # M√©tricas principais
        criar_metricas_principais(resultado)
        
        # Recomenda√ß√µes
        st.markdown("---")
        exibir_recomendacoes(resultado)
        
        # Tabela de resultados
        st.markdown("---")
        exibir_tabela_resultados(resultado)
        
        # Bot√£o de exporta√ß√£o
        st.divider()
        col1, col2 = st.columns([1, 3])
        
        with col1:
            if st.button("üì• Exportar para Excel", type="secondary", key="exportar_btn"):
                exportar_excel(resultado)
        
        with col2:
            st.info("üí° Dica: Clique em 'Exportar para Excel' para baixar os resultados da an√°lise avan√ßada.")

def parse_mapeamento(texto):
    """Parse do mapeamento manual de colunas"""
    mapeamento = {}
    for item in texto.split(';'):
        if ',' in item:
            idx, chave = item.split(',')
            mapeamento[chave.strip()] = int(idx.strip())
    return mapeamento

if __name__ == "__main__":
    main() 